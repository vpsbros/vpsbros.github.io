<!DOCTYPE html>
<html>
  <head>
    <style type="text/css">
      /* Layout & base */

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
  background: #020617;
  color: #e5e7eb;
  line-height: 1.7;
  margin: 0;
}

main,
.container,
.markdown-body,
.wrapper,
.page-content {
  max-width: 840px;
  margin: 2.5rem auto 4rem;
  padding: 0 1.5rem;
}

/* Headings */

h1, h2, h3, h4 {
  font-weight: 700;
  line-height: 1.3;
  color: #f9fafb;
  margin-top: 2.2rem;
  margin-bottom: 0.6rem;
}

h1 {
  font-size: 2rem;
}

h2 {
  font-size: 1.5rem;
  border-left: 4px solid #38bdf8;
  padding-left: 0.6rem;
}

h3 {
  font-size: 1.2rem;
  color: #e0f2fe;
}

/* Text & lists */

p,
ul,
ol {
  margin: 0.4rem 0 1rem;
}

li {
  margin: 0.25rem 0;
}

/* Links */

a {
  color: #38bdf8;
  text-decoration: none;
  border-bottom: 1px dashed rgba(56, 189, 248, 0.4);
}

a:hover {
  border-bottom-style: solid;
}

/* Code blocks */

pre {
  background: #020617;
  padding: 0.9rem 1rem;
  border-radius: 0.5rem;
  border: 1px solid #1f2937;
  overflow-x: auto;
  box-shadow: 0 8px 20px rgba(15, 23, 42, 0.8);
}

code {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.9em;
}

/* Blockquotes & dividers */

blockquote {
  border-left: 4px solid #4b5563;
  padding-left: 0.75rem;
  margin: 1.5rem 0;
  color: #9ca3af;
}

hr {
  border: none;
  border-top: 1px solid #1f2937;
  margin: 2rem 0;
}

    </style>
  </head>
  <body>
<h1 id="-vps-">整理一些VPS使用技巧</h1>
<p>作者：<a href="https://www.vpsbros.com">vpsbros</a></p>
<h2 id="-vps-">刚拿到 VPS 先做的几件小事</h2>
<h3 id="-ssh-">换端口 + 关密码登录（SSH）</h3>
<pre><code class="lang-bash"><span class="hljs-comment"># 编辑 sshd 配置</span>
<span class="hljs-attribute">sudo</span> vim /etc/ssh/sshd_config

<span class="hljs-comment"># 确保包含：</span>
Port <span class="hljs-number">22222</span>              <span class="hljs-comment"># 换一个非 22 端口</span>
PermitRootLogin <span class="hljs-literal">no</span>      <span class="hljs-comment"># 禁止 root 直接登录</span>
PasswordAuthentication <span class="hljs-literal">no</span>  <span class="hljs-comment"># 禁止密码登录，只允许密钥</span>
</code></pre>
<p>然后：</p>
<pre><code class="lang-bash"><span class="hljs-attribute">sudo systemctl restart ssh</span>
</code></pre>
<p>记得先<strong>用新端口开一个新终端测试能登录</strong>，确认没问题再关掉旧会话，避免把自己锁在门外。</p>
<h3 id="-sudo-">加一个普通用户 + sudo 权限</h3>
<pre><code class="lang-bash"><span class="hljs-symbol">sudo</span> <span class="hljs-keyword">adduser </span>deploy
<span class="hljs-symbol">sudo</span> usermod -aG sudo deploy
</code></pre>
<p>之后就用 <code>deploy</code> 登录，<code>sudo</code> 提权，不要天天 root 满地跑。</p>
<h3 id="-ufw-">开基础防火墙（UFW）</h3>
<pre><code class="lang-bash">sudo apt <span class="hljs-keyword">update</span>
sudo apt <span class="hljs-keyword">install</span> ufw

# 允许 SSH 新端口
sudo ufw <span class="hljs-keyword">allow</span> <span class="hljs-number">22222</span>/tcp

# 如果跑 Web
sudo ufw <span class="hljs-keyword">allow</span> <span class="hljs-number">80</span>,<span class="hljs-number">443</span>/tcp

sudo ufw <span class="hljs-keyword">enable</span>
sudo ufw <span class="hljs-keyword">status</span>
</code></pre>
<p>简单暴力，比裸奔强太多。</p>
<h2 id="-">包管理和系统维护的小习惯</h2>
<h3 id="-">固定版本，避免一键全升级搞崩</h3>
<p>普通服务器别上来就 <code>apt upgrade -y</code>，推荐：</p>
<pre><code class="lang-bash">sudo apt <span class="hljs-keyword">update</span>
sudo apt <span class="hljs-keyword">list</span> <span class="hljs-comment">--upgradable</span>
</code></pre>
<p>先看看有哪些要升级，关键软件（数据库、nginx）可以<strong>单独升级</strong>：</p>
<pre><code class="lang-bash">sudo apt <span class="hljs-keyword">install</span> <span class="hljs-comment">--only-upgrade nginx</span>
</code></pre>
<h3 id="-">定期清理废包和日志</h3>
<pre><code class="lang-bash"><span class="hljs-comment"># 清理下载的旧包</span>
sudo apt autoremove
sudo apt clean

<span class="hljs-comment"># 日志按大小轮转（默认就有 logrotate）</span>
sudo logrotate -d <span class="hljs-regexp">/etc/</span>logrotate.conf    <span class="hljs-comment"># 先 dry-run 看一下</span>
</code></pre>
<h2 id="-tmux-screen-">用 tmux/screen 防止“窗口一关进度清零”</h2>
<h3 id="-tmux">长时间任务必进 tmux</h3>
<pre><code class="lang-bash">sudo apt install tmux

tmux <span class="hljs-keyword">new</span> -s work
<span class="hljs-meta"># 里面随便跑：</span>
docker build ...
apt upgrade ...
<span class="hljs-meta"># 分离会话</span>
Ctrl+b 然后按 d

<span class="hljs-meta"># 再次连接</span>
tmux attach -t work
</code></pre>
<p>只要 VPS 不重启，你关了本地终端也不会中断任务。</p>
<h3 id="-tmux">延时高用跳板机+tmux</h3>
<p>路由不是两点之间直线最短，如果中美直连延时过高，考虑中-日-美跳板登录，配合tmux提升维护效率和体验。</p>
<h2 id="-">别手配环境，容器化是好文明</h2>
<h3 id="-docker-">用 docker 跑服务，减少“环境地狱”</h3>
<p>安装 docker（以 Debian/Ubuntu 为例，可用官方脚本）：</p>
<pre><code class="lang-bash">curl -fsSL http<span class="hljs-variable">s:</span>//<span class="hljs-built_in">get</span>.docker.<span class="hljs-keyword">com</span> | sudo <span class="hljs-keyword">sh</span>
sudo usermod -aG docker $USER
</code></pre>
<p>然后：</p>
<pre><code class="lang-bash"><span class="hljs-comment"># 跑一个临时测试容器</span>
docker <span class="hljs-built_in">run</span> <span class="hljs-comment">--rm -it ubuntu bash</span>
</code></pre>
<p>想装 Redis、MariaDB、Nextcloud 之类，尽量优先用官方镜像，方便版本控制和迁移。</p>
<h3 id="-docker-compose-">用 docker-compose 管一组服务</h3>
<p><code>docker-compose.yml</code> 小技巧：把数据目录映射到宿主机的 <code>/srv</code> 或 <code>/data</code>，迁移时直接打包那几个目录就行。</p>
<pre><code class="lang-yaml"><span class="hljs-symbol">services:</span>
  <span class="hljs-symbol">db:</span>
    <span class="hljs-symbol">image:</span> <span class="hljs-symbol">mariadb:</span><span class="hljs-number">11</span>
    <span class="hljs-symbol">volumes:</span>
      - <span class="hljs-regexp">/srv/db</span><span class="hljs-symbol">:/var/lib/mysql</span>
</code></pre>
<h2 id="-">备份：不是可选，是必选</h2>
<h3 id="-rclone">最便宜的备份：打包 + rclone</h3>
<p>安装 rclone，把对象存储 / 网盘挂进去：</p>
<pre><code class="lang-bash">rclone <span class="hljs-built_in">config</span>
<span class="hljs-comment"># 按向导把远端存储配好（比如 Backblaze、S3 兼容、OneDrive）</span>
</code></pre>
<p>然后写个脚本：</p>
<pre><code class="lang-bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">set</span> <span class="hljs-_">-e</span>
DATE=$(date +%F)

tar czf /tmp/site-<span class="hljs-variable">$DATE</span>.tar.gz /srv /etc/nginx /etc/letsencrypt

rclone copy /tmp/site-<span class="hljs-variable">$DATE</span>.tar.gz remote:server-backup/
rm /tmp/site-<span class="hljs-variable">$DATE</span>.tar.gz
</code></pre>
<p>配个 crontab：</p>
<pre><code class="lang-bash">crontab -<span class="hljs-built_in">e</span>
0 3 * * * /usr/<span class="hljs-keyword">local</span>/bin/backup.<span class="hljs-keyword">sh</span>
</code></pre>
<p>真正出事那一刻，你会感谢这个脚本。</p>
<h3 id="-">数据库单独备份</h3>
<p>以 MySQL/MariaDB 为例：</p>
<pre><code class="lang-bash">mysqldump -u root -p --all-databases &gt; /srv/backups/db-$(<span class="hljs-keyword">date</span> +%F).sql
</code></pre>
<h2 id="-">监控和告警：不要等用户告诉你网站挂了</h2>
<h3 id="-systemd-">用 systemd 自带的重启策略</h3>
<p>服务挂了自动拉起来，配置示例 <code>/etc/systemd/system/myapp.service</code>：</p>
<pre><code class="lang-ini"><span class="hljs-section">[Service]</span>
<span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure
<span class="hljs-attr">RestartSec</span>=<span class="hljs-number">5</span>
</code></pre>
<p>改完：</p>
<pre><code class="lang-bash">sudo<span class="hljs-keyword"> system</span>ctl daemon-reload
sudo<span class="hljs-keyword"> system</span>ctl enable myapp
sudo<span class="hljs-keyword"> system</span>ctl restart myapp
</code></pre>
<h3 id="-">装个简单的监控工具</h3>
<p>比如 <code>htop</code>、<code>iotop</code>、<code>ncdu</code>：</p>
<pre><code class="lang-bash">sudo apt <span class="hljs-keyword">install</span> htop iotop ncdu
</code></pre>
<ul>
<li><code>htop</code> 看总体资源</li>
<li><code>iotop</code> 看磁盘谁在疯狂读写</li>
<li><code>ncdu</code> 看是哪个目录吃满了硬盘</li>
</ul>
<h3 id="-uptime-">外部监控（免费 uptime）</h3>
<p>去找一个免费的站点可用性监控（例如 UptimeRobot、Better Uptime 之类），加个 HTTP 检测，服务挂了给你发邮件 / 消息，比你自己盯着踏实得多。</p>
<h2 id="nginx-">Nginx / 反向代理的小技巧</h2>
<h3 id="-nginx">统一反代，域名交给 Nginx</h3>
<p>在 VPS 内部服务尽量都跑在 <code>127.0.0.1:xxxx</code> 上，然后用 Nginx 做反向代理，这样：</p>
<ul>
<li>换证书、一键 HTTPS 都在 Nginx 搞</li>
<li>后端服务端口不用对外开放，安全性更好</li>
</ul>
<p>基本范式：</p>
<pre><code class="lang-nginx"><span class="hljs-section">server</span> {
    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;
    <span class="hljs-attribute">server_name</span> example.com;

    <span class="hljs-attribute">location</span> / {
        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:3000;
        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;
        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;
    }
}
</code></pre>
<h3 id="-acme-sh-certbot-">用 acme.sh / certbot 自动续期证书</h3>
<p>以 certbot 为例：</p>
<pre><code class="lang-bash">sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d example<span class="hljs-selector-class">.com</span> -d www<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.com</span>
</code></pre>
<p>弄好之后会自动续期，一般不用你管。</p>
<h2 id="-">日志与调试的小套路</h2>
<h3 id="-journald-">统一把应用日志打到 journald 或文件</h3>
<ul>
<li>systemd 管理的服务：<code>journalctl -u your-service -f</code></li>
<li>自己写的程序，日志落到 <code>/var/log/xxx.log</code>，再配 <code>logrotate</code> 滚动</li>
</ul>
<h3 id="nginx-">nginx 日志分域名存</h3>
<p>在 server 块里指定：</p>
<pre><code class="lang-nginx">access_log /<span class="hljs-built_in">var</span>/<span class="hljs-built_in">log</span>/nginx/<span class="hljs-built_in">example</span>.access.<span class="hljs-built_in">log</span>;
error_log /<span class="hljs-built_in">var</span>/<span class="hljs-built_in">log</span>/nginx/<span class="hljs-built_in">example</span>.<span class="hljs-built_in">error</span>.<span class="hljs-built_in">log</span>;
</code></pre>
<p>出问题时不用在一坨混合日志里翻。</p>
<h3 id="-tail-f-grep-">善用 <code>tail -f</code> 和 <code>grep</code></h3>
<pre><code class="lang-bash">tail -f <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>access.log | <span class="hljs-keyword">grep</span> <span class="hljs-string">'500'</span>
</code></pre>
<h2 id="-windows-vps-">从 Windows 上传/下载文件到 VPS 的顺手玩法</h2>
<h3 id="-winscp-filezilla">图形化：用 WinSCP / FileZilla</h3>
<ul>
<li>协议选 SFTP</li>
<li>主机填 VPS IP</li>
<li>端口填你改过的 SSH 端口（如 22222）</li>
<li>用户名就是你创建的那个普通用户</li>
</ul>
<p>左边本地，右边 VPS，拖拽就能传文件，适合上传网站包、备份下载回本地。</p>
<h3 id="-scp">命令行：用 scp</h3>
<p>在 Windows 安装好 OpenSSH 或用 WSL：</p>
<pre><code class="lang-bash"><span class="hljs-comment"># 上传本地文件到 VPS</span>
<span class="hljs-attribute">scp</span> -P <span class="hljs-number">22222</span> localfile.txt user<span class="hljs-variable">@your</span>-vps-ip:/home/user/

<span class="hljs-comment"># 下载 VPS 文件到本地</span>
scp -P <span class="hljs-number">22222</span> user<span class="hljs-variable">@your</span>-vps-ip:/home/user/file.txt .
</code></pre>
<h2 id="-">降低“不可预期操作”的风险</h2>
<h3 id="-">在命令行提示里显示当前服务器名称</h3>
<p>编辑 <code>~/.bashrc</code>：</p>
<pre><code class="lang-bash"><span class="hljs-attr">PS1</span>=<span class="hljs-string">"\u@\h:\w$ "</span>
</code></pre>
<p>这样你能一眼分辨现在在本机还是线上 VPS，避免把危险命令敲在生产上。</p>
<h3 id="-echo-">危险命令前面先 echo 一次</h3>
<p>例如清理：</p>
<pre><code class="lang-bash"><span class="hljs-comment"># 先看一眼会删什么</span>
echo rm -rf <span class="hljs-regexp">/var/www/</span>*

<span class="hljs-comment"># 再真正执行</span>
rm -rf <span class="hljs-regexp">/var/www/</span>*
</code></pre>
<p>看似啰嗦，能救命。</p>
<h2 id="ssh-">SSH 再进阶一点：多机管理、跳板机</h2>
<h3 id="-ssh-config-">~/.ssh/config 写好，少敲很多字</h3>
<p>本地电脑上建/改 <code>~/.ssh/config</code>：</p>
<pre><code class="lang-sshconfig">Host my-vps
    HostName <span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span>
    User deploy
    Port <span class="hljs-number">22222</span>
    IdentityFile ~/.ssh/id_ed25519
</code></pre>
<p>以后直接：</p>
<pre><code class="lang-bash">ssh <span class="hljs-keyword">my</span>-vps
scp <span class="hljs-built_in">file</span>.txt <span class="hljs-keyword">my</span>-vps:/home/deploy/
</code></pre>
<h3 id="-vps-">把 VPS 当“跳板机”</h3>
<p>如果家里有内网机器（NAS、树莓派），可以只开 VPS 的 22/22222 端口，通过 SSH 反向隧道把家里设备“挂”到 VPS 上，用 <code>ssh -R</code>：</p>
<pre><code class="lang-bash"><span class="hljs-selector-tag">ssh</span> <span class="hljs-selector-tag">-R</span> 10022<span class="hljs-selector-pseudo">:localhost</span><span class="hljs-selector-pseudo">:22</span> <span class="hljs-selector-tag">deploy</span>@<span class="hljs-keyword">your</span>-<span class="hljs-keyword">vps</span>-<span class="hljs-keyword">ip</span>
</code></pre>
<p>然后在 VPS 上就可以：</p>
<pre><code class="lang-bash">ssh localhost -<span class="hljs-selector-tag">p</span> <span class="hljs-number">10022</span>
</code></pre>
<p>配合 autossh 可以长期保持隧道不断线。</p>
<h2 id="-fail2ban-">用 Fail2ban/防火墙防一波暴力破解</h2>
<h3 id="fail2ban-ban-ip">Fail2ban 自动 ban 爆破 IP</h3>
<pre><code class="lang-bash">sudo apt install fail2ban
sudo cp <span class="hljs-regexp">/etc/</span>fail2ban<span class="hljs-regexp">/jail.conf /</span>etc<span class="hljs-regexp">/fail2ban/</span>jail.local
</code></pre>
<p>在 <code>jail.local</code> 里启用 sshd：</p>
<pre><code class="lang-ini"><span class="hljs-section">[sshd]</span>
<span class="hljs-attr">enabled</span> = <span class="hljs-literal">true</span>
<span class="hljs-attr">port</span>    = <span class="hljs-number">22222</span>
<span class="hljs-attr">maxretry</span> = <span class="hljs-number">5</span>
</code></pre>
<p>然后：</p>
<pre><code class="lang-bash">sudo systemctl <span class="hljs-built_in">restart</span> fail2ban
sudo fail2ban-client <span class="hljs-built_in">status</span> sshd
</code></pre>
<h3 id="iptables-ufw-ip-ssh-">iptables/ufw 做“只允许少数 IP 登录 SSH”</h3>
<p>如果你有固定 IP，可以直接限制：</p>
<pre><code class="lang-bash">sudo ufw deny <span class="hljs-number">22222</span>/tcp
sudo ufw allow <span class="hljs-keyword">from</span> 你的IP <span class="hljs-keyword">to</span> <span class="hljs-literal">any</span> <span class="hljs-keyword">port</span> <span class="hljs-number">22222</span> <span class="hljs-keyword">proto</span> tcp
</code></pre>
<h2 id="-">性能相关的小操作</h2>
<h3 id="-vps-swap">给小内存 VPS 加个 swap</h3>
<p>很多 1G 内存的小鸡不带 swap，编译、跑大一点的东西容易 OOM：</p>
<pre><code class="lang-bash">sudo fallocate <span class="hljs-_">-l</span> 1G /swapfile
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile
<span class="hljs-built_in">echo</span> <span class="hljs-string">'/swapfile none swap sw 0 0'</span> | sudo tee <span class="hljs-_">-a</span> /etc/fstab
</code></pre>
<h3 id="-ncdu-">用 ncdu 找出“谁吃满了磁盘”</h3>
<pre><code class="lang-bash"><span class="hljs-attribute">sudo</span> ncdu /
</code></pre>
<p>交互界面慢慢浏览，删准的，不删错的。</p>
<h3 id="-">简单的内核参数优化（谨慎使用）</h3>
<p>在 <code>/etc/sysctl.d/99-tuning.conf</code>：</p>
<pre><code class="lang-conf">net<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.somaxconn</span> = <span class="hljs-number">1024</span>
net<span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_tw_reuse</span> = <span class="hljs-number">1</span>
vm<span class="hljs-selector-class">.swappiness</span> = <span class="hljs-number">10</span>
</code></pre>
<p>应用：</p>
<pre><code class="lang-bash">sudo sysctl <span class="hljs-comment">--system</span>
</code></pre>
<p>不要网上抄一大堆完全不懂的参数，三五个足够。</p>
<h2 id="-">多站点、多服务的域名与反代管理</h2>
<h3 id="-vps-">一台 VPS 上挂一堆子域名</h3>
<p>例如：</p>
<ul>
<li><code>blog.example.com</code> → 127.0.0.1:4000</li>
<li><code>pan.example.com</code> → 127.0.0.1:9000</li>
<li><code>status.example.com</code> → 127.0.0.1:8080</li>
</ul>
<p>对应建多个 <code>server</code> 块，每个 <code>server_name</code> 一个子域，内部用不同端口或不同 docker 容器。</p>
<h3 id="-">用一个统一的“反代入口”</h3>
<p>特别建议 <code>/srv/apps/app-name</code> 约定好目录结构，例如：</p>
<pre><code class="lang-text">/srv
  /<span class="hljs-keyword">blog
</span>  /nextcloud
  /status
</code></pre>
<p>Nginx 配置都放 <code>/etc/nginx/sites-enabled/xxx.conf</code>，备份时打包 <code>/srv</code> + <code>/etc/nginx</code> 就差不多够了。</p>
<h2 id="-">自动化：别手工复刻同一台机器十次</h2>
<h3 id="-">写一个“初始化脚本”</h3>
<p>比如 <code>init-vps.sh</code>：</p>
<pre><code class="lang-bash"><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">set</span> <span class="hljs-_">-e</span>

adduser --disabled-password --gecos <span class="hljs-string">""</span> deploy || <span class="hljs-literal">true</span>
usermod <span class="hljs-_">-a</span>G sudo deploy

apt update
apt install -y ufw htop tmux fail2ban

ufw allow 22222/tcp
ufw <span class="hljs-built_in">enable</span>
</code></pre>
<p>以后新 VPS 只需：</p>
<pre><code class="lang-bash">curl -sS <span class="hljs-string">https:</span><span class="hljs-comment">//your-domain.com/init-vps.sh | sudo bash</span>
</code></pre>
<h3 id="-ansible-terraform-">尝试用 Ansible / Terraform 管多台</h3>
<p>当你有不止一台 VPS，用 <a href="https://www.ansible.com/">Ansible</a> 这类工具可以：</p>
<ul>
<li>批量改配置</li>
<li>批量更新服务</li>
<li>确保多台机器配置一致</li>
</ul>
<p>前期学习成本稍高，但长远能省很多时间和脑细胞。</p>
<h2 id="-vpn-vps-">用 VPN / 内网组网让多台 VPS 互相“贴身”</h2>
<h3 id="wireguard-tailscale">WireGuard / Tailscale</h3>
<p>给多台 VPS 安装 WireGuard 或 <a href="https://tailscale.com/">Tailscale</a>：</p>
<ul>
<li>每台机器会拿到一个内网 IP（比如 100.x.x.x）</li>
<li>内部服务直接绑内网 IP，不对公网开端口</li>
<li>你电脑也加入这个网络，就像这些 VPS 都在你家局域网里</li>
</ul>
<p>特别适合：数据库、后台管理面板、内网工具。</p>
<h3 id="-">只暴露一层反向代理到公网</h3>
<p>例如：</p>
<ul>
<li>VPS A：对外，只跑 Nginx + WireGuard</li>
<li>VPS B/C：只跑应用，通过内网互通</li>
</ul>
<p>外网只能打到 A，其他都在内网里，安全性直线上升。</p>
<h2 id="-">日志、审计和“谁干了啥”</h2>
<h3 id="-shell-history-">把重要操作写进 shell history 注释</h3>
<p>例如：</p>
<pre><code class="lang-bash"><span class="hljs-comment"># 升级数据库到 11.1</span>
sudo apt install <span class="hljs-comment">--only-upgrade postgresql</span>
</code></pre>
<p>以后 <code>history</code> 里就不只有命令，还有人类语言的注释，排查问题会少骂过去的自己。</p>
<h3 id="-">开启命令审计（简单做法）</h3>
<p>在 <code>~/.bashrc</code> 里加：</p>
<pre><code class="lang-bash"><span class="hljs-keyword">export</span> HISTTIMEFORMAT=<span class="hljs-string">"%F %T "</span>
<span class="hljs-keyword">export</span> PROMPT_COMMAND=<span class="hljs-string">'history -a'</span>
</code></pre>
<p>这样每条历史都有时间戳。</p>
<h2 id="-">“上生产前先在沙盒玩一遍”</h2>
<h3 id="-vps-">先在本地 / 测试 VPS 排练</h3>
<p>真正要改 Nginx、数据库、大版本升级前，可以：</p>
<ul>
<li>买个最便宜的小 VPS，当“沙盒”</li>
<li>把配置和数据复制过去，先在那里升级一遍，看会不会炸</li>
<li>解决问题后再在正式机操作</li>
</ul>
<h3 id="-nginx-t-systemd-test-">善用 <code>nginx -t</code>、<code>systemd --test</code> 之类的检查命令</h3>
<p>改配置前：</p>
<pre><code class="lang-bash"><span class="hljs-attribute">sudo nginx -t</span>
</code></pre>
<p>失败就别 reload，省掉线上直接 502 的尴尬。</p>
<h2 id="-">轻量运维界面：面板类工具</h2>
<h3 id="-">用面板管理只是辅助手段，不要完全依赖</h3>
<p>像 Cockpit（集成系统管理的）、Portainer（docker 管理）、一些开源主机面板，可以适当用：</p>
<ul>
<li>图形化管理容器</li>
<li>查看日志、基本监控</li>
<li>简单重启服务</li>
</ul>
<p>但真正关键的东西（备份脚本、自动化）还是建议在命令行层面掌握，不被某个面板绑死。</p>
<h2 id="-vps-">把 VPS 当“个人数字实验室”</h2>
<p>一些有意思、但不那么“正经商业”的玩法：</p>
<ul>
<li>自建同步盘：Nextcloud / Seafile，当自己的“无广告网盘”</li>
<li>自建 RSS 聚合：FreshRSS / Miniflux，把信息流掌握在自己手里</li>
<li>自建密码库同步端：Bitwarden 家族的自建版</li>
<li>自建图床、短链服务：方便日常分享</li>
<li>自建小型搜索、笔记、LLM 服务，当自己的“第二大脑”</li>
</ul>
<p>当你慢慢把这些东西挂在自己的 VPS 上，就会发现：那不只是一台远程电脑，而是一个跟着你长大的数字小宇宙。</p>
  </body>
  </html>